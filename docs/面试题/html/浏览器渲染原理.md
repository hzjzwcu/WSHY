# 渲染页面：浏览器的工作原理

## 目标

快速加载、流畅交互

## 影响性能的因素

资源加载时间、浏览器单线程执行

## 进入页面

输入url或者通过点击连接进入页面，此时需要经历几个步骤

### DNS查询

页面一般会引用多个域名的资源，如字体、脚本、图片、广告等，需要进行**多次DNS查询**，如果是手机移动网络，还要经过**基站中转**，可能存在性能问题

### TCP握手

获取到IP后会进行三次握手与服务器建立连接

### TLS协商

为了建立https安全连接，还要进行TLS协商，进行了3次往返，让服务器获取浏览器生成的密钥，结束时还要两次挥手，相当于**TCP与TLS在开始请求前一共有8次往返**

> 这一步骤增加了页面等待时间，但会让请求内容更安全

![DNS 查询、TCP 握手和 TLS 5 步握手（包括服务器和客户端之间的 clienthello、serverhello 以及证书、clientkey 和完成消息）。](./%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86.assets/ssl.jpg)

## 请求&响应

浏览器正式发送请求到服务器，服务器接收并响应，首次一般是请求HTML页面

## TCP慢启动

硬件和网络能接收的容量是有限的，所以会分批发送，第一个数据包是14KB大小，下一个数据包会加倍到28KB，依次加倍直到达到预定的阈值或者拥塞

## 解析

解析就是浏览器将数据转为DOM和CSSOM的过程，浏览器**收到第一个包就会开始解析**，因此第一个包里的数据很重要，要包含浏览器的初始模板

### 构建DOM树

HTML转为对象的过程，如果发现资源文件比如图片脚本，会异步请求资源并继续解析，js脚本会阻塞渲染和解析

### 预加载

构建DOM树会占用主线程，此时预加载机制会在后台提前请求资源，不会等解析器找到引用才开始请求，css预加载可能会阻塞js,因为js会查询css属性

### 构建CSSOM树

CSS转为对象，通常很快，时间小于一次DNS查询

### js编译

js代码会被转为抽象语法树，浏览器将其传递到解释器中，输出在主线程上执行，这过程叫编译

### 构建AOM

辅助功能树主要用于屏幕阅读器等无障碍功能

## 渲染

### Render树

将DOM树和CSSOM树合成一个Render树，凑够DOM根节点开始构建，遍历每个可见节点

display:none的节点不会出现在render树中



每个可见节点都应用了其 CSSOM 规则。Render 树保存所有具有内容和计算样式的可见节点——将所有相关样式匹配到 DOM 树中的每个可见节点，并根据 [CSS 级联](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade)确定每个节点的计算样式。

### [Layout](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#layout)

第四步是在渲染树上运行布局以计算每个节点的几何体。布局是确定呈现树中所有节点的宽度、高度和位置，以及确定页面上每个对象的大小和位置的过程。回流是对页面的任何部分或整个文档的任何后续大小和位置的确定。

构建渲染树后，开始布局。渲染树标识显示哪些节点（即使不可见）及其计算样式，但不标识每个节点的尺寸或位置。为了确定每个对象的确切大小和位置，浏览器从渲染树的根开始遍历它。

在网页上，大多数东西都是一个盒子。不同的设备和不同的桌面意味着无限数量的不同的视区大小。在此阶段，考虑到视区大小，浏览器将确定屏幕上所有不同框的尺寸。以视区的大小为基础，布局通常从 body 开始，用每个元素的框模型属性排列所有 body 的子孙元素的尺寸，为不知道其尺寸的替换元素（例如图像）提供占位符空间。

第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流。在我们的示例中，假设初始布局发生在返回图像之前。由于我们没有声明图像的大小，因此一旦知道图像大小，就会有回流。

### [绘制](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#绘制)

最后一步是将各个节点绘制到屏幕上，第一次出现的节点称为 [first meaningful paint (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/First_meaningful_paint)。在绘制或光栅化阶段，浏览器将在布局阶段计算的每个框转换为屏幕上的实际像素。绘画包括将元素的每个可视部分绘制到屏幕上，包括文本、颜色、边框、阴影和替换的元素（如按钮和图像）。浏览器需要非常快地完成这项工作。

为了确保平滑滚动和动画，占据主线程的所有内容，包括计算样式，以及回流和绘制，必须让浏览器在 16.67 毫秒内完成。在 2048x1536 分辨率的 iPad 上，有超过 314.5 万像素将被绘制到屏幕上。那是很多像素需要快速绘制。为了确保重绘的速度比初始绘制的速度更快，屏幕上的绘图通常被分解成数层。如果发生这种情况，则需要进行合成。

绘制可以将布局树中的元素分解为多个层。将内容提升到 GPU 上的层（而不是 CPU 上的主线程）可以提高绘制和重新绘制性能。有一些特定的属性和元素可以实例化一个层，包括 [``](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video) 和 [``](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas)，任何 CSS 属性为 [`opacity`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/opacity) 、3D [`transform`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform)、[`will-change`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change) 的元素，还有一些其他元素。这些节点将与子节点一起绘制到它们自己的层上，除非子节点由于上述一个（或多个）原因需要自己的层。

分层确实可以提高性能，但是它以内存管理为代价，因此不应作为 web 性能优化策略的一部分过度使用。

### [Compositing](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#compositing)

当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。

当页面继续加载资源时，可能会发生回流（回想一下我们迟到的示例图像），回流会触发重新绘制和重新组合。如果我们定义了图像的大小，就不需要重新绘制，只需要重新绘制需要重新绘制的层，并在必要时进行合成。但我们没有包括图像大小！从服务器获取图像后，渲染过程将返回到布局步骤并从那里重新开始。

## [交互](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#交互)

一旦主线程绘制页面完成，你会认为我们已经“准备好了”，但事实并非如此。如果加载包含 JavaScript（并且延迟到 [`onload`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/load_event) 事件激发后执行），则主线程可能很忙，无法用于滚动、触摸和其他交互。

[Time to Interactive (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Time_to_interactive)（TTI）是测量从第一个请求导致 DNS 查询和 SSL 连接到页面可交互时所用的时间——可交互是 [First Contentful Paint (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/First_contentful_paint) 之后的时间点，页面在 50ms 内响应用户的交互。如果主线程正在解析、编译和执行 JavaScript，则它不可用，因此无法及时（小于 50ms）响应用户交互。

在我们的示例中，可能图像加载很快，但 `anotherscript.js` 文件可能是 2MB，而且用户的网络连接很慢。在这种情况下，用户可以非常快地看到页面，但是在下载、解析和执行脚本之前，就无法滚动。这不是一个好的用户体验。避免占用主线程，如下面的网页测试示例所示：

![通过快速连接，主线程被 JavaScript 文件下载、解析和执行占用](./%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86.assets/visa_network.png)

在本例中，DOM 内容加载过程花费了超过 1.5 秒的时间，主线程在这段时间内完全被占用，对单击事件或屏幕点击没有响应。
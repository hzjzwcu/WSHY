# HTTP连接

## 2 HTTP 连接

### 2.1 HTTP 1.1

- 长链接
    - HTTP协议的初始版本中，客户端每次请求数据都需要做 **三次握手和四次挥手**，为了避免这部分资源的浪费，部分浏览器请求时会加入 `Connection: keep-alive` 字段要求服务器不关闭TCP链接，握手完成后可以发送多个请求。
    - HTTP1.1 版本引入了**长连接**，即TCP链接默认不关闭，直到客户端显式地发送 `Connection: close` 或者超时才会挥手关闭链接。

- 管道机制
    - 从前发送请求后需等待及接收响应，才能发送下一个请求，管道化技术是同时**并行发送**多个请求
    - 一个TCP链接可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的，这就是`Content-length` 字段的作用，**声明本次回应的数据长度**。

- 分块传输
    - 使用 `Content-Length` 字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度，对于一些耗时的动态操作来说，意味着，服务器要**等到所有操作完成，才能发送数据**，显然这样的效率不高，更好的方法是产生一块数据就发送一块，采用流模式取代缓存模式
    - 1.1 规定可以不使用 **content-length** ，而是用分块传输编码，只要请求或响应头信息有 `Transfer-Encoding` 字段，就表明响应将由**数量未定的数据块**组成
    - 同一个 TCP 链接里面，所有的数据通信是**按次序进行**的，服务器只有处理完一个回应才会进行下一个回应，如果前面的请求慢，后面就会有需要请求排队，称为**对头阻塞**

### 2.2 HTTP2

- 二进制协议
    - HTTP1.1 中头是文本，数据体是文本或者二进制，而 HTTP2 头和数据体都是二进制，统称为帧
    - 二进制协议支持**额外定义帧**，使用文本则难以实现
- 多工
    - HTTP2 复用TCP链接，在一个链接中，**请求和响应都是并发**，而且不用按照顺序一一对应，避免阻塞
    - 这种双向的，实时通信就叫做多工

- 数据流
    - HTTP2的数据包是不按顺序发送的，同一个链接里面连续的数据包也可能属于不同的回应，因此必须要对数据包做**标记**，指出他属于哪个回应
    - HTTP2将每个请求或回应的所有数据包，称为一个数据流，每个数据流都有一个独一无二的编号，数据包发送的时候，都必须标记数据流ID，另外还规定，**客户端发出的数据流，ID一律为奇数，服务器发布的，ID为偶数**
    - 客户端和服务器都可以取消某一次请求，同时保证TCP链接还开着
    - 客户端还可以指定数据流的优先级，优先级越高，服务器就会越早回应

- 压缩头信息

    > HTTP每次请求都必须附上所有信息，比如Cookie，这会浪费很多带宽也影响速度，而HTTP2对这一点做了优化，引入了头信息压缩机制

    - 头信息使用 gzip 或 compress 压缩后再发送
    - 客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送这个字段只发送索引号这样就提高速度了

- 服务器推送

    - HTTP2允许服务器未经过请求**主动向客户端发送资源**，这就叫服务器推送

    - 常见场景是客户端请求一个网页，服务器可以预期到客户端请求网页后很可能会再请求静态资源，所有就主动把这些静态资源随着网页一起发给客户端了

## 3 压缩传输数据资源

- gzip 响应数据压缩

    - 浏览器自动添加 `Accept-Encoding` 字段标识，服务器会将资源压缩后再返回  `Content-Encoding: gzip`
    - 即使没有字段标识，如果客户端支持，服务器也可以返回 `Content-Encoding: gzip` 供客户端解析
    - 服务器代码也**请求数据压缩**，在 nginx 中配置即可
    - gzip一般是**请求数据压缩**，比如 js，css 等

- 请求数据压缩，一般只限于文本
    - **压缩头信息**，见上文
    - **请求数据压缩**，例如发表博客的请求，正文数据非常庞大
















































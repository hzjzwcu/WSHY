# 从输入URL到页面展示的过程

## 一、用户输入

浏览器智能匹配url，搜索历史记录，书签等，给出提示，如果有记录，还可以从缓存中展示网页

## 二、DNS查找域名对应的IP

请求前的第一步是要进行**DNS解析**，获取域名的IP地址。如果请求协议是`HTTPS`，那么还需要建立`TLS`连接。

## 三、发送请求

- **TCP连接**：建立TCP连接
- **构建请求**：客户端构建请求，包含请求方法、协议版本、请求头（包含该域名路径相关的`Cookie`）、请求正文
- **发送请求**
- **响应请求**：服务器接收到请求后，生成响应数据（包括响应行、响应头和响应体等信息），并发给客户端
- 客户端解析响应头的内容

## 四、重定向

如果发现返回的状态码是`301`或者`302`，那么说明服务器需要浏览器重定向到其他URL。这时网络进程会从响应头的`Location`字段里面读取重定向的地址，重新发起新的请求，比如输入了`google.com`，会被重定向到`www.google.com`，有利于`SEO`以及缓存

## 五、处理响应

浏览器会根据响应头中的`Content-Type`的值来决定如何显示响应体的内容，比如`text/html`就是告诉浏览器，服务器返回的数据是`HTML`格式，常见的类型有：

| 值                         | 说明     | 备注 |
| -------------------------- | -------- | ---- |
| `text/html`                | HTML     |      |
| `text/plain`               | 纯文本   |      |
| `application/json`         | JSON数据 |      |
| `application/octet-stream` | 文件下载 |      |
| `multipart/form-data`      | 表单上传 |      |

更多可见：[Content-Type](https://www.runoob.com/http/http-content-type.html) 

## 六、准备渲染进程

如果是`Content-Type`是`text/html`，那么浏览器则会继续进行准备渲染了，需要创建一个进程来渲染页面

- 通常情况下，每打开一个新页面，浏览器就会创建一个单独的渲染进程；
- 如果从A页面打开B页面，且A和B都属于同一站点的话，那么B页面复用A页面的渲染进程；如果是其他情况，浏览器进程则会为B创建一个新的渲染进程。

之后浏览器会更新界面状态，包括了安全状态、地址栏的URL、前进后退的历史状态，并刷新页面

## 浏览器显示HTML

解析HTML构建DOM树，解析CSS构建渲染树，渲染树构建完成后就会开始布局和绘制，这里涉及回流和重绘

- dom需要浏览器计算位置和大小，这叫reflow重排或回流
- 颜色，字体等确定后浏览器开始绘制内容，这叫做重绘repain

文档解析遇到js文件会阻塞渲染，因此一般将js放在文件末尾

js解析是由浏览器的js引擎完成的，如谷歌中是v8

## 获取html中的资源

如图片视频css等资源，浏览器会重新发起请求获取



### [#](https://blog.poetries.top/browser-working-principle/guide/part1/lesson04.html#_5-渲染阶段)5. 渲染阶段

一旦文档被提交，渲染进程便开始页面解析和子资源加载了，关于这个阶段的完整过程，我会在下一篇文章中来专门介绍。这里你只需要先了解一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。如下所示：

![img](./assets/bef45eb5b01c34e328486004feedd658.png)

至此，一个完整的页面就生成了。那文章开头的“从输入URL到页面展示，这中间发生了什么？”这个过程极其“串联”的问题也就解决了。

## [#](https://blog.poetries.top/browser-working-principle/guide/part1/lesson04.html#总结-从输入url到页面展示-这中间发生了什么)总结：从输入URL到页面展示，这中间发生了什么

- 用户输入url并回车

- 浏览器进程检查url，组装协议，构成完整的url

- 浏览器进程通过进程间通信（IPC）把url请求发送给网络进程

- 网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程

- 如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下

    ：

    - 进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）
    - 利用ip地址和服务器建立tcp连接
    - 构建请求头信息
    - 发送请求头信息
    - 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容

- 网络进程解析响应流程

    ；

    - 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步 （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。
    - 200响应处理：检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。

- 准备渲染进程

    - 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程

- 传输数据、更新状态

    - 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
    - 渲染进程接收完数据后，向浏览器发送“确认提交”
    - 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面

## [#](https://blog.poetries.top/browser-working-principle/guide/part1/lesson04.html#总结)总结

好了，今天就到这里，下面我来简单总结下这篇文章的要点：

- 服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。
- Chrome默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。
- 浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。
- 导航流程很重要，它是网络加载流程和渲染流程之间的一座桥梁，如果你理解了导航流程，那么你就能完整串起来整个页面显示流程，这对于你理解浏览器的工作原理起到了点睛的作用